{"version":3,"file":"./bundle.js","mappings":"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","sources":["webpack://tictactoe-2.0/./js/draw.js","webpack://tictactoe-2.0/./js/gameLogic.js","webpack://tictactoe-2.0/./js/main.js"],"sourcesContent":["import {\n    win,\n    getIndexesOfTheWinningStrategy,\n    k,\n\n} from './gameLogic';\n\n\nexport function drawSymbol(symbol) {\n    symbol.classList.remove('hidden');\n};\n\nexport function paintOverWinCells(indexArr, playingField) {\n\n    let rows = playingField.children;\n\n    for (const coord of indexArr) {\n        let cell = rows[coord[0]].children[coord[1]];\n        cell.classList.add('paint__over-green');\n    }\n\n\n}\n\nexport function paintOverAllCells(playingField) {\n    // playingField.children[0].children[0].style.backgroundColor = 'yellow';\n\n}\n\n\nexport function isPaintOverAllWinCells(arr, arrTransponse, playingField, k) {\n\n    if (getIndexesOfTheWinningStrategy(arr, arrTransponse, k)) {\n\n        paintOverWinCells(getIndexesOfTheWinningStrategy(arr, arrTransponse, k), playingField);\n\n        return win = true;\n\n    } else {\n\n        return false;\n\n    }\n};\n\n","import {\n    drawSymbol,\n    isPaintOverAllWinCells,\n    paintOverWinCells,\n\n} from './draw';\n\nconst crossWins = document.querySelector('.game-score-for-cross');\nconst zerosWins = document.querySelector('.game-score-for-zeros');\nconst playerMoveNumber = document.querySelector('.player__move-number');\n\nconst templateZero = '<img class=\"image-symbol zero-img\" src=\"images/zero.png\" alt=\"zero\">';\nconst templateCross = '<img class=\"image-symbol cross-img\" src=\"images/cross.png\" alt=\"cross\">';\n\nexport let n = 0;\nexport let k = 0;\n\nlet moveNumber = 0,\n    winCounterForCross = 0,\n    winCounterForZeros = 0,\n    drawCondition = 0;\n\nexport let win = false;\n\nexport const resetWinCounter = () => {\n    winCounterForCross = 0;\n    winCounterForZeros = 0;\n    zerosWins.innerHTML = '0';\n    crossWins.innerHTML = '0';\n}\n\nexport function resetPlayingField(playingField, gameMenu) {\n    playingField.innerHTML = '';\n    gameMenu.classList.add('hidden');\n    win = false;\n    moveNumber = 0;\n};\n\nexport function resetPlayingMatrix(arr) {\n    for (let i = 0; i < arr.length; i++) {\n\n        resetRow(arr[i]);\n    }\n    return arr;\n};\nfunction resetRow(row) {\n    for (let i = 0; i < row.length; i++) {\n        row[i] = 0;\n    }\n    return row;\n};\n\nexport function resetGameCells(playingField) {\n\n    win = false;\n    for (const row of playingField.children) {\n        for (const cell of row.children) {\n            cell.innerHTML = '';\n            cell.className = 'cell';\n        }\n    }\n    moveNumber = 0;\n    playerMoveNumber.innerHTML = 'Ходят крестики ❌';\n\n}\n\nexport function createMatrix(n) {\n    var result = [];\n\n    for (var i = 0; i < n; i++) {\n        result.push(new Array(n).fill(0));\n    }\n    return result;\n\n};\n\nfunction transposeMatrix(m) {\n    return m[0].map((x, i) => m.map(x => x[i]));\n}\n\nfunction getIndexWinRightDiagonal(arr) {\n\n    let indexWinCells = [[], [], []];\n    let indexForCell = [];\n\n    let j = 0;\n    for (let i = 0; i < arr.length; i++) {\n\n        if (arr[i][j] === 1) {\n\n            indexWinCells[i][0] = i;\n            indexWinCells[i][1] = j;\n            j++;\n\n        } else {\n            return indexWinCells = null;\n        }\n    }\n    for (let i = 0; i < arr.length; i++) {\n        indexForCell[i] = indexWinCells[i].join('');\n\n    }\n\n    return indexForCell;\n}\n\nfunction getIndexWinLeftDiagonal(arr) {\n\n    let indexWinCells = [[], [], []];\n    let indexForCell = [];\n\n    let j = 0;\n    for (let i = 2; i < arr.length; i--) {\n\n        if (i === -1) {\n            break;\n        }\n\n        if (arr[i][j] === 1) {\n\n            indexWinCells[i][0] = i;\n            indexWinCells[i][1] = j\n            j++;\n\n        } else {\n            return indexWinCells = null;\n        }\n    }\n\n    for (let i = 0; i < arr.length; i++) {\n        indexForCell[i] = indexWinCells[i].join('');\n\n    }\n\n    return indexForCell;\n}\n\n\nfunction сheckIfWinningRow(row, k) {\n\n    let indexRowI = [];\n    let counter = 0;\n\n    for (let i = 0; i < row.length; i++) {\n\n\n        if (row[i] === 0) {\n            counter = 0;\n            indexRowI = [];\n            continue;\n        }\n        if (row[i] === 1) {\n            counter++;\n            indexRowI.push(i);\n\n        }\n        if (counter === k) {\n\n\n            return indexRowI;\n\n        }\n        // else {\n\n        //     return indexRowI = null;\n\n        // }\n    }\n\n    return null;\n\n}\n\n/**\n * \n * @param {Array} arr \n * @returns \n */\nfunction getIndexWinRow(arr, k) {\n\n    let indexRow = [];\n    let indexJ = -1;\n\n    arr.forEach((el, i) => {\n        let indArr = сheckIfWinningRow(el, k);\n\n\n        if (indArr) {\n\n            indexRow = indArr;\n            indexJ = i;\n        }\n    });\n\n    if (indexJ == -1) {\n        return indexRow = null;\n    }\n\n    arr.forEach((el, i) => {\n        indexRow[i] = [indexJ, indexRow[i]];\n        //indexRow[i] = indexRow[i].split('').map(Number);\n    });\n\n    return indexRow;\n};\n\n/**\n * \n * @param {Array} arr \n * @returns \n */\nfunction getIndexWinColumn(arrTransponse, k) {\n\n    let indexRow = [];\n    let indexJ = -1;\n\n    arrTransponse.forEach((el, i) => {\n        if (сheckIfWinningRow(el, k)) {\n            indexRow = сheckIfWinningRow(el, k);\n            indexJ = i;\n        }\n    });\n\n    if (indexJ == -1) {\n        return indexRow = null;\n    }\n\n    arrTransponse.forEach((el, i) => {\n        indexRow[i] += `${indexJ}`;\n        indexRow[i] = indexRow[i].split('').map(Number);\n    });\n\n    return indexRow;\n\n};\n\nexport function getIndexesOfTheWinningStrategy(arr, arrTransponse, k) {\n\n    let indexArr = [];\n\n    if (getIndexWinLeftDiagonal(arr)) {\n\n        return indexArr = getIndexWinLeftDiagonal(arr);\n\n    } else if (getIndexWinRightDiagonal(arr)) {\n\n        return indexArr = getIndexWinRightDiagonal(arr);\n\n    } else if (getIndexWinRow(arr, k)) {\n\n        return indexArr = getIndexWinRow(arr, k);\n\n    } else if (getIndexWinColumn(arrTransponse, k)) {\n\n        return indexArr = getIndexWinColumn(arrTransponse, k);\n\n    }\n\n}\n\nfunction checkDiagonal(matrix, i, j, k) {\n    var outputCoordinates = [];\n\n    for(let i_index = 0, counter = 0, row = i, diagonal = j; i_index < matrix[i].length; i_index++, row++, diagonal++){\n        if (row >= matrix[i].length || \n            row < 0 || \n            diagonal >= matrix[i].length || \n            diagonal < 0) {\n            break;\n        } else if(matrix[row][diagonal] == 1 ) {\n            outputCoordinates.push([row, diagonal]);\n            counter++;\n\n            if(counter == k){\n                return outputCoordinates;\n            }\n        }else{\n            outputCoordinates = [];\n            counter = 0;\n        }\n    }\n\n    outputCoordinates = [];\n\n    for(let i_index = 0, counter = 0, row = i, diagonal = j; i_index < matrix[i].length; i_index++, row--, diagonal--){\n        if (row >= matrix[i].length || \n            row < 0 || \n            diagonal >= matrix[i].length || \n            diagonal < 0) {\n            break;\n        } else if(matrix[row][diagonal] == 1 ) {\n            outputCoordinates.push([row, diagonal]);\n            counter++;\n\n            if(counter == k){\n                return outputCoordinates;\n            }\n        }else{\n            outputCoordinates = [];\n            counter = 0;\n        }\n    }\n\n    outputCoordinates = [];\n\n    for(let i_index = 0, counter = 0, row = i, diagonal = j; i_index < matrix[i].length; i_index++, row--, diagonal++){\n        if (row >= matrix[i].length || \n            row < 0 || \n            diagonal >= matrix[i].length || \n            diagonal < 0) {\n            break;\n        } else if(matrix[row][diagonal] == 1 ) {\n            outputCoordinates.push([row, diagonal]);\n            counter++;\n\n            if(counter == k){\n                return outputCoordinates;\n            }\n        }else{\n            outputCoordinates = [];\n            counter = 0;\n        }\n    }\n\n    outputCoordinates = [];\n\n    for(let i_index = 0, counter = 0, row = i, diagonal = j; i_index < matrix[i].length; i_index++, row++, diagonal--){\n        if (row >= matrix[i].length || \n            row < 0 || \n            diagonal >= matrix[i].length || \n            diagonal < 0) {\n            break;\n        } else if(matrix[row][diagonal] == 1 ) {\n            outputCoordinates.push([row, diagonal]);\n            counter++;\n\n            if(counter == k){\n                return outputCoordinates;\n            }\n        }else{\n            outputCoordinates = [];\n            counter = 0;\n        }\n    }\n\n    return null;\n}\n\nfunction checkLine(matrix, i, j, k) {\n    var outputCoordinates = [];\n\n    for (var j_index = 0, counter = 0; j_index < matrix[i].length; j_index++) {\n        if (matrix[i][j_index] == 1) {\n            outputCoordinates.push([i, j_index]);\n            counter++;\n\n            if (counter == k) {\n                return outputCoordinates;\n            }\n        } else {\n            outputCoordinates = [];\n            counter = 0;\n        }\n    }\n\n    outputCoordinates = [];\n\n    for (var i_index = 0, counter = 0; i_index < matrix[j].length; i_index++) {\n        if (matrix[i_index][j] == 1) {\n            outputCoordinates.push([i_index, j]);\n            counter++;\n\n            if (counter == k) {\n                return outputCoordinates;\n            }\n        } else {\n            outputCoordinates = [];\n            counter = 0;\n        }\n    }\n\n    return null;\n}\n\nfunction checkWinner(matrix, i, j, k,playingField) {\n    let rowCoords = checkLine(matrix,i, j, k);\n    let diagonalCoords = checkDiagonal(matrix,i, j, k);\n    \n    if (rowCoords) {\n        paintOverWinCells(rowCoords, playingField);\n        win = true;\n    }\n\n    if (diagonalCoords) {\n        paintOverWinCells(diagonalCoords, playingField);\n        win = true;\n    }\n}\n\nexport function updateСell(event, i, j, fieldOfСrosses, fieldOfZeros, playingField, k) {\n    if (win === true) {\n        return;\n    }\n\n    let target = event.target;\n\n    if (target.classList.contains('active-cell') || target.classList.contains('image-symbol')) {\n        return;\n    }\n\n    target.classList.add('active-cell');\n\n    if (moveNumber) {\n        target.innerHTML = templateZero;\n        fieldOfZeros[i][j] = 1;\n        checkWinner(fieldOfZeros, i, j, k, playingField);\n        playerMoveNumber.innerHTML = 'Ходят крестики ❌';\n    } else {\n        target.innerHTML = templateCross;\n        fieldOfСrosses[i][j] = 1;\n        checkWinner(fieldOfСrosses, i, j, k, playingField);\n        playerMoveNumber.innerHTML = 'Ходят нолики ⭕';\n    }\n\n    moveNumber = !moveNumber;\n\n    // let fieldOfСrossesTranspone = transposeMatrix(fieldOfСrosses);\n    // let fieldOfZerosTranspone = transposeMatrix(fieldOfZeros);\n\n    // if (isPaintOverAllWinCells(fieldOfСrosses, fieldOfСrossesTranspone, playingField, k) === true) {\n\n    //     playerMoveNumber.innerHTML = 'Победили крестики!';\n    //     winCounterForCross++;\n    //     crossWins.innerHTML = `${winCounterForCross}`;\n    //     // win = true;\n\n\n    // } else if (isPaintOverAllWinCells(fieldOfZeros, fieldOfZerosTranspone, playingField, k) === true) {\n\n    //     playerMoveNumber.innerHTML = 'Победили нолики!';\n    //     winCounterForZeros++;\n    //     zerosWins.innerHTML = `${winCounterForZeros}`;\n    //     // win = true;\n\n    // } /*else {\n\n    //     drawCondition++;\n\n    //     if (drawCondition === 9) {\n    //         playerMoveNumber.innerHTML = 'Ничья!';\n\n    //         paintOverAllCells(playingField);\n    //     }\n    // }*/\n\n\n\n}\n","import {\n    resetWinCounter,\n    resetPlayingField,\n    createMatrix,\n    updateСell,\n    resetPlayingMatrix,\n    resetGameCells,\n    n,\n    k,\n} from './gameLogic';\n\n\nexport const playingField = document.querySelector('.playing__field');\n\nconst gameMenu = document.querySelector('.menu-section');\n\nconst cell = document.querySelector('#cell');\n\nconst playButton3x3 = document.querySelector('.button-play-3x3');\nconst playButtonNxN = document.querySelector('.button-play-NxN');\nconst buttonPlayAgain = document.querySelector('.button-play-again');\nconst restartButton = document.querySelector('.img-restart');\n\nconst conditionForNxN = document.querySelector('.condition-for-NxN');\nconst goButton = document.querySelector('.btn-go')\n\n\nlet fieldOfСrosses = [];\nlet fieldOfZeros = [];\n\n/**\n * Функция для работы с табами\n * @param {*} btn \n * @returns \n */\nfunction makeTabActive(btn) {\n    const menu = document.querySelector('.menu-list');\n    const activeBtn = menu.querySelector('.active');\n    \n    if (btn.classList.contains('active-game')) {\n        btn.classList.toggle('active-game');\n        return;\n    }\n\n    if (activeBtn) {\n        if (btn === activeBtn) {\n            activeBtn.classList.remove('active');\n            resetPlayingField(playingField, gameMenu);\n            return;\n        }\n        else {\n            activeBtn.classList.remove('active');\n            btn.classList.add('active')\n            //makeButtonActive(btn);\n        }\n\n    } else {\n        btn.classList.add('active')\n        //makeButtonActive(btn);\n    }\n}\n\nfunction createPlayingField(playingField, n, cell, k, btn) {\n    fieldOfСrosses = createMatrix(n);\n    fieldOfZeros = createMatrix(n);\n\n\n    for (let i = 0; i < n; i++) {\n\n        let tr = document.createElement('tr');\n\n        for (let j = 0; j < n; j++) {\n\n            let td = cell.content.cloneNode(true).firstElementChild;\n\n            td.dataset.index = `${i}${j}`;\n\n            tr.appendChild(td)\n\n\n            td.addEventListener('click', (event) => updateСell(event, i, j, fieldOfСrosses, fieldOfZeros, playingField, k));\n\n        }\n        playingField.appendChild(tr);\n\n\n    };\n\n    gameMenu.classList.remove('hidden');\n\n};\n\nplayButton3x3.addEventListener('click', (e) => {\n    k = 3;\n    createPlayingField(playingField, 3, cell, k, e.target);\n    makeTabActive(e.target);\n    conditionForNxN.classList.add('hidden');\n});\n\n\nplayButtonNxN.addEventListener('click', (e) => {\n\n    resetPlayingField(playingField, gameMenu);\n    makeTabActive(e.target);\n    conditionForNxN.classList.toggle('hidden');\n\n});\n\ngoButton.addEventListener('click', () => {\n\n    n = + document.querySelector('.input-for-N').value;\n    k = + document.querySelector('.input-for-K').value;\n\n    if (n == 0 || k == 0) {\n        alert('Некорректные данные!')\n        return;\n    }\n\n    conditionForNxN.classList.add('hidden');\n    playButtonNxN.classList.add('active-game');\n\n    createPlayingField(playingField, n, cell, k, playButtonNxN);\n})\n\nrestartButton.addEventListener('click', () => {\n\n    restartButton.classList.toggle('rotate');\n    resetWinCounter();\n\n});\n\nbuttonPlayAgain.addEventListener('click', () => {\n\n    fieldOfСrosses = resetPlayingMatrix(fieldOfСrosses);\n    fieldOfZeros = resetPlayingMatrix(fieldOfZeros);\n\n    resetGameCells(playingField);\n\n});"],"names":["paintOverWinCells","indexArr","playingField","rows","children","coord","classList","add","crossWins","document","querySelector","zerosWins","playerMoveNumber","n","k","moveNumber","winCounterForCross","winCounterForZeros","resetPlayingField","gameMenu","innerHTML","resetPlayingMatrix","arr","i","length","resetRow","row","createMatrix","result","push","Array","fill","checkWinner","matrix","j","rowCoords","outputCoordinates","j_index","counter","i_index","checkLine","diagonalCoords","diagonal","checkDiagonal","event","fieldOfZeros","target","contains","cell","playButton3x3","playButtonNxN","buttonPlayAgain","restartButton","conditionForNxN","goButton","makeTabActive","btn","activeBtn","toggle","remove","createPlayingField","tr","createElement","td","content","cloneNode","firstElementChild","dataset","index","appendChild","addEventListener","e","value","alert","className","resetGameCells"],"sourceRoot":""}